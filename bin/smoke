#!/usr/bin/env ruby

require 'bundler/setup'
require 'typed_ruby'
require 'pry'

registry = TypedRuby::Registry.new
source = <<-RUBY

  module M
    def module_method
      m
    end
  end

  class A
    # include M

    def instance_method(s)
      s + 'string'
    end

    # def self.class_method1
    #   [1, 2, 3]
    # end

    # class << self
    #   def class_method2
    #     { key: 'value' }
    #   end
    # end
  end

RUBY

registry.register_module(
  __M = TypedRuby::Signatures::Module.new(
    name: 'M'
  )
)

__M.define_method(
  TypedRuby::Signatures::Method.new(
    name: 'module_method',
    arguments: [],
    returns: TypedRuby::Types::InstanceOf.new(registry.find_class('String'))
  )
)

registry.register_class(
  __A = TypedRuby::Signatures::Class.new(
    name: 'A',
    superclass: registry.find_class('Object')
  )
)

__A.include(__M)

__A.define_method(
  TypedRuby::Signatures::Method.new(
    name: 'instance_method',
    arguments: [
      TypedRuby::Signatures::Arguments::Required.new(
        name: 's',
        type: TypedRuby::Types::InstanceOf.new(registry.find_class('String'))
      )
    ],
    returns: TypedRuby::Types::InstanceOf.new(registry.find_class('Integer'))
  )
)

__A.define_singleton_method(
  TypedRuby::Signatures::Method.new(
    name: 'class_method1',
    arguments: [],
    returns: TypedRuby::Types::InstanceOf.new(registry.find_class('Array'))
  )
)

ast = TypedRuby::AST::Parser.new(file: 'eval', source: source).parse

reducer = TypedRuby::AST::Reducer.new(ast: ast, registry: registry)

result = reducer.result

puts result
